<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notificaciones Autom√°ticas</title>
    <link rel="stylesheet" href="css/notifications.css">
    <link rel="stylesheet" href="css/video-notifications.css">
    <link rel="stylesheet" href="css/codes.css">
</head>
<body>
    <!-- Plantilla para notificaci√≥n estilo 1 -->
    <audio id="notification-sound" src="sounds/notification/notification.wav" preload="auto"></audio>

    <template id="template-style1">
        <div class="notification-box style-1">
            <div class="notification-title"></div>
            <div class="notification-message"></div>
        </div>
    </template>

    <!-- Plantilla para notificaci√≥n estilo 2 -->
    <template id="template-style2">
        <div class="notification-box style-2">
            <div class="upper-container">
                <img class="profile-image" src="" alt="Perfil">
                <div class="notification-title"></div>
            </div>
            <div class="notification-message"></div>
        </div>
    </template>

    <div id="notifications-root"></div>
    <div id="video-container">
        <video id="notification-video" playsinline autoplay></video>
    </div>
    <div id="code-display"></div>

    <script>
        const notificationsContainer = [];
        const maxNotifications = 4;
        const storePath = 'store';
        const notificationCatalog = {}; // Almacenar configuraciones cargadas
        const notificationQueue = []; // Cola de notificaciones pendientes
        let isPlayingNotification = false; // Flag para saber si se est√° reproduciendo una notificaci√≥n
        
        // --- VARIABLES PARA C√ìDIGOS ---
        let activeCode = null;
        let codeElement = null;
        let codeTimeout = null;
        let codeBlinkInterval = null;
        let animationFrameId = null; // Variable global para la animaci√≥n
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
        let colorIndex = 0;

        function ensureRoot() {
            let root = document.getElementById('notifications-root');
            if (!root) {
                root = document.createElement('div');
                root.id = 'notifications-root';
                document.body.appendChild(root);
            }
            return root;
        }

        // Cargar el cat√°logo din√°micamente desde store/
        async function loadNotificationCatalog() {
            try {
                console.log('üîÑ Iniciando carga del cat√°logo...');
                const response = await fetch(`${storePath}/manifest.json`);
                if (!response.ok) {
                    console.error('‚ùå manifest.json no encontrado. Status:', response.status);
                    console.error('   Crea un archivo store/manifest.json con: {"version": "1.0", "notifications": ["hijodelamaraca"]}');
                    return;
                }

                const manifest = await response.json();
                console.log('üìã Manifest cargado:', manifest);

                if (!manifest.notifications || manifest.notifications.length === 0) {
                    console.warn('‚ö† El manifest no contiene notificaciones');
                    return;
                }

                for (const notificationId of manifest.notifications) {
                    try {
                        console.log(`  üì¶ Cargando: ${notificationId}...`);
                        const configResponse = await fetch(`${storePath}/${notificationId}/config.json`);
                        if (configResponse.ok) {
                            const config = await configResponse.json();
                            notificationCatalog[notificationId] = {
                                ...config,
                                videoPath: `${storePath}/${notificationId}/video.mp4`
                            };
                            console.log(`  ‚úì ${notificationId} cargado`);
                        } else {
                            console.error(`  ‚ùå config.json no encontrado para: ${notificationId} (Status: ${configResponse.status})`);
                        }
                    } catch (error) {
                        console.error(`  ‚ùå Error cargando ${notificationId}:`, error);
                    }
                }

                console.log('üé¨ Cat√°logo completo:', notificationCatalog);
                console.log(`   Total notificaciones cargadas: ${Object.keys(notificationCatalog).length}`);
            } catch (error) {
                console.error('‚ùå Error cargando cat√°logo:', error);
            }
        }

        // Reproducir video de notificaci√≥n
        async function playNotificationVideo(notifId) {
            try {
                const config = notificationCatalog[notifId];
                if (!config || !config.videoPath) {
                    console.warn(`‚ùå Video no encontrado para: ${notifId}`);
                    return 0;
                }

                const videoElement = document.getElementById('notification-video');
                const videoContainer = document.getElementById('video-container');

                videoElement.src = config.videoPath;
                videoContainer.classList.remove('hide'); // Remover clase hide si existe
                videoContainer.style.display = 'block';

                // Esperar a que el video cargue para obtener la duraci√≥n
                return new Promise((resolve) => {
                    const handleLoadedMetadata = () => {
                        const duration = videoElement.duration * 1000; // convertir a ms
                        console.log(`‚ñ∂ Reproduciendo video: ${notifId} (${(duration/1000).toFixed(2)}s)`);
                        videoElement.play().catch(err => console.warn('Error reproduciendo video:', err));

                        // Ocultar video cuando termine
                        const handleEnded = () => {
                            videoContainer.classList.add('hide');
                            setTimeout(() => {
                                videoContainer.style.display = 'none';
                            }, 300);
                            videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);
                            videoElement.removeEventListener('ended', handleEnded);
                            resolve(duration);
                        };

                        videoElement.addEventListener('ended', handleEnded);
                    };

                    const handleError = () => {
                        console.error(`‚ùå Error cargando video: ${config.videoPath}`);
                        console.error('   Verifica que el archivo video.mp4 existe en la carpeta');
                        videoContainer.classList.add('hide');
                        setTimeout(() => {
                            videoContainer.style.display = 'none';
                        }, 300);
                        videoElement.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        videoElement.removeEventListener('error', handleError);
                        resolve(0);
                    };

                    videoElement.addEventListener('loadedmetadata', handleLoadedMetadata);
                    videoElement.addEventListener('error', handleError);
                });
            } catch (error) {
                console.error('Error reproduciendo video:', error);
                return 0;
            }
        }

        // Mostrar notificaci√≥n din√°mica (sin cat√°logo)
        function showDynamicNotification(data) {
            const caseType = data.caseType || 1;
            const templateName = caseType === 2 ? 'style2' : 'style1';
            const template = document.getElementById(`template-${templateName}`);
            
            if (!template) {
                console.error(`‚ùå Template no encontrado: template-${templateName}`);
                return;
            }
            
            const notificationElement = template.content.cloneNode(true).querySelector('.notification-box');
            
            // Aplicar datos
            const titleElement = notificationElement.querySelector('.notification-title');
            const messageElement = notificationElement.querySelector('.notification-message');
            
            if (titleElement && data.titleText) titleElement.textContent = data.titleText;
            if (messageElement && data.messageText) messageElement.textContent = data.messageText;
            
            // Si es style2, aplicar imagen de perfil
            if (templateName === 'style2' && data.profileImage) {
                const profileImg = notificationElement.querySelector('.profile-image');
                if (profileImg) {
                    profileImg.src = data.profileImage.src || data.profileImage;
                    profileImg.alt = data.profileImage.alt || 'Perfil';
                }
            }
            
            console.log(`‚úì Notificaci√≥n din√°mica creada (${templateName}) - T√≠tulo: "${data.titleText}", Mensaje: "${data.messageText}"`);
            
            // Mostrar
            const root = ensureRoot();
            root.appendChild(notificationElement);
            setTimeout(() => notificationElement.classList.add('show'), 60);
            notificationsContainer.unshift(notificationElement);
            
            // Limitar cantidad
            if (notificationsContainer.length > maxNotifications) {
                const oldNotif = notificationsContainer.pop();
                oldNotif.classList.remove('show');
                setTimeout(() => oldNotif.remove(), 260);
            }
            
            // Auto-remover despu√©s de 4 segundos
            setTimeout(() => {
                notificationElement.classList.remove('show');
                setTimeout(() => notificationElement.remove(), 260);
            }, 4000);
        }

        async function nuevaNotificacion(notifId, data = {}) {
            const config = notificationCatalog[notifId];
            if (!config) {
                console.error(`‚ùå Notificaci√≥n no encontrada: "${notifId}"`);
                console.error('   IDs disponibles en cat√°logo:', Object.keys(notificationCatalog));
                console.error('   Datos recibidos:', data);
                console.error('   üí° Aseg√∫rate de que:');
                console.error('      1. El ID existe en store/manifest.json');
                console.error('      2. El backend env√≠a el ID correcto (item_id del item de la tienda)');
                return;
            }

            console.log(`üì¢ Mostrando notificaci√≥n: ${notifId}`, 'Config:', config, 'Data:', data);

            // Mostrar la notificaci√≥n PRIMERO (si hay template)
            let notificationElement = null;
            if (config.template) {
                const templateId = `template-${config.template}`;
                const template = document.getElementById(templateId);
                if (template) {
                    notificationElement = template.content.cloneNode(true).querySelector('.notification-box');

                    // Priorizar datos din√°micos (data) sobre config
                    const titleText = data.titleText || config.titleText || '';
                    const messageText = data.messageText || config.messageText || '';
                    
                    // Aplicar textos
                    const titleElement = notificationElement.querySelector('.notification-title');
                    const messageElement = notificationElement.querySelector('.notification-message');
                    
                    if (titleElement) titleElement.textContent = titleText;
                    if (messageElement) messageElement.textContent = messageText;
                    
                    // Para style-2, manejar imagen de perfil
                    if (config.template === 'style2') {
                        const profileImg = notificationElement.querySelector('.profile-image');
                        if (profileImg && data.profileImage) {
                            profileImg.src = data.profileImage.src || data.profileImage;
                            profileImg.alt = data.profileImage.alt || 'Perfil';
                        }
                    }

                    console.log(`‚úì Notificaci√≥n creada - T√≠tulo: "${titleText}", Mensaje: "${messageText}"`);

                    const root = ensureRoot();
                    root.appendChild(notificationElement);
                    setTimeout(() => notificationElement.classList.add('show'), 60);
                    notificationsContainer.unshift(notificationElement);

                    // Garantizar l√≠mite de notificaciones simult√°neas
                    if (notificationsContainer.length > maxNotifications) {
                        const oldNotif = notificationsContainer.pop();
                        oldNotif.classList.remove('show');
                        setTimeout(() => oldNotif.remove(), 260);
                    }
                } else {
                    console.warn(`‚ö† Template no encontrado: ${templateId}`);
                }
            } else {
                console.warn(`‚ö† No hay template definido en config para: ${notifId}`);
            }

            // Reproducir video (al mismo tiempo que la notificaci√≥n)
            const videoDuration = await playNotificationVideo(notifId);
            
            // Auto-remover la notificaci√≥n basado en duraci√≥n del video (o 4200ms por defecto)
            if (notificationElement) {
                const duration = videoDuration || 4200;
                setTimeout(() => {
                    notificationElement.classList.remove('show');
                    setTimeout(() => notificationElement.remove(), 260);
                }, duration);
            }
        }

        // Procesar cola de notificaciones
        async function processNotificationQueue() {
            if (notificationQueue.length === 0) {
                isPlayingNotification = false;
                return;
            }

            isPlayingNotification = true;
            const nextNotification = notificationQueue.shift();
            
            console.log(`üìã Procesando notificaci√≥n de la cola: ${nextNotification.notifId} (Pendientes: ${notificationQueue.length})`);
            
            await nuevaNotificacion(nextNotification.notifId, nextNotification.data);
            
            // Esperar un poco antes de procesar la siguiente
            setTimeout(processNotificationQueue, 500);
        }

        // Manejar notificaci√≥n entrante
        function handleIncomingNotification(notifId, data = {}) {
            // Agregar a la cola
            notificationQueue.push({ notifId, data });
            console.log(`‚è≥ Notificaci√≥n en cola: ${notifId} (Total en cola: ${notificationQueue.length})`);

            // Si no hay notificaci√≥n reproduci√©ndose, iniciar el procesamiento
            if (!isPlayingNotification) {
                processNotificationQueue();
            }
        }

        // --- FUNCIONES PARA C√ìDIGOS RECOMPENSABLES ---
        function showCode(code, duration, blink_start) {
            removeCode(); // Remover c√≥digo anterior si existe
            
            activeCode = code;
            console.log(`üéÅ Mostrando c√≥digo: ${code} (V√°lido por ${duration}s)`);
            
            const container = document.getElementById('code-display');
            codeElement = document.createElement('div');
            codeElement.className = 'code-element';
            codeElement.textContent = code;
            codeElement.style.color = colors[0];
            container.appendChild(codeElement);
            
            // Calcular ancho aproximado del c√≥digo (44px font-size + letter-spacing)
            const codeWidth = code.length * 30; // Aproximado: 30px por car√°cter
            const codeHeight = 54; // Altura aproximada del texto
            
            // Posici√≥n inicial aleatoria DENTRO de los l√≠mites visibles
            const maxX = Math.max(100, window.innerWidth - codeWidth - 50);
            const maxY = Math.max(100, window.innerHeight - codeHeight - 50);
            let x = 50 + Math.random() * (maxX - 50);
            let y = 50 + Math.random() * (maxY - 50);
            codeElement.style.left = `${x}px`;
            codeElement.style.top = `${y}px`;
            
            // Velocidad aleatoria m√°s sutil
            let speedX = (Math.random() - 0.5) * 1.2;
            let speedY = (Math.random() - 0.5) * 1.2;
            
            let timeLeft = duration;
            let isBlinking = false;
            let colorChangeCounter = 0;
            
            // Animaci√≥n de movimiento continuo
            const animateCode = () => {
                if (!codeElement || !codeElement.parentNode) {
                    return; // Detener si el elemento fue removido
                }
                
                x += speedX;
                y += speedY;
                
                // Calcular l√≠mites din√°micos
                const codeWidth = code.length * 30;
                const codeHeight = 54;
                const minX = 20;
                const minY = 20;
                const maxX = window.innerWidth - codeWidth - 20;
                const maxY = window.innerHeight - codeHeight - 20;
                
                // Rebotar en los bordes con suavidad
                if (x <= minX || x >= maxX) {
                    speedX = -speedX;
                    x = Math.max(minX, Math.min(x, maxX)); // Corregir posici√≥n
                }
                if (y <= minY || y >= maxY) {
                    speedY = -speedY;
                    y = Math.max(minY, Math.min(y, maxY)); // Corregir posici√≥n
                }
                
                // Asegurar que siempre est√© dentro de los l√≠mites
                x = Math.max(minX, Math.min(x, maxX));
                y = Math.max(minY, Math.min(y, maxY));
                
                codeElement.style.left = `${x}px`;
                codeElement.style.top = `${y}px`;
                
                // Cambiar color cada 30 frames (m√°s suave)
                colorChangeCounter++;
                if (colorChangeCounter >= 30 && !isBlinking) {
                    colorIndex = (colorIndex + 1) % colors.length;
                    codeElement.style.color = colors[colorIndex];
                    colorChangeCounter = 0;
                }
                
                animationFrameId = requestAnimationFrame(animateCode);
            };
            
            animateCode();
            
            // Iniciar parpadeo en los √∫ltimos 30 segundos
            const blinkStartTime = (duration - blink_start) * 1000;
            setTimeout(() => {
                isBlinking = true;
                console.log(`‚è≥ C√≥digo parpadeando... (${blink_start}s restantes)`);
                codeBlinkInterval = setInterval(() => {
                    codeElement.style.opacity = codeElement.style.opacity === '0' ? '1' : '0';
                }, 300);
            }, blinkStartTime);
            
            // Auto-remover despu√©s de la duraci√≥n
            codeTimeout = setTimeout(() => {
                console.log(`‚ùå C√≥digo expirado: ${code}`);
                removeCode();
            }, duration * 1000);
        }
        
        function removeCode() {
            if (codeTimeout) clearTimeout(codeTimeout);
            if (codeBlinkInterval) clearInterval(codeBlinkInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (codeElement) {
                // Fadeout suave
                codeElement.style.opacity = '0';
                setTimeout(() => {
                    if (codeElement && codeElement.parentNode) {
                        codeElement.remove();
                    }
                    codeElement = null;
                }, 500); // Esperar a que termine el fadeout
            }
            activeCode = null;
        }

        // --- Conexi√≥n WebSocket con reconexi√≥n autom√°tica ---
        let ws;
        let isConnecting = false;
        let reconnectAttempts = 0;
        
        function connectWebSocket() {
            if (isConnecting) {
                console.log('[WS] ‚è≥ Ya hay un intento de conexi√≥n en curso...');
                return;
            }
            
            isConnecting = true;
            console.log(`[WS] üîÑ Intentando conectar... (Intento #${reconnectAttempts + 1})`);
            
            try {
                ws = new WebSocket('ws://localhost:8765');
            } catch (error) {
                console.error('[WS] ‚ùå Error creando WebSocket:', error);
                isConnecting = false;
                setTimeout(connectWebSocket, 3000);
                return;
            }

            ws.addEventListener('open', () => {
                console.log('[WS] ‚úÖ Conectado a ws://localhost:8765');
                isConnecting = false;
                reconnectAttempts = 0;
            });

            ws.addEventListener('message', (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('[WS] üì® Mensaje recibido:', data);
                    
                    // Manejar notificaciones
                    if (data && data.type === 'notification') {
                        // CASO 1: Notificaci√≥n de tienda (con notificationId)
                        if (data.notificationId) {
                            const notifId = data.notificationId;
                            
                            // Validar que el notifId no sea un placeholder
                            if (notifId.includes('<') || notifId.includes('>')) {
                                console.error('[WS] ‚ùå notificationId inv√°lido:', notifId);
                                console.error('      Verifica que el backend env√≠e el ID correcto del item');
                                console.error('      Datos recibidos:', JSON.stringify(data, null, 2));
                                return;
                            }
                            
                            console.log('[WS] üéÅ Notificaci√≥n de tienda:', notifId);
                            handleIncomingNotification(notifId, data);
                        } 
                        // CASO 2: Notificaci√≥n de evento (sin notificationId, usa caseType)
                        else if (data.caseType) {
                            console.log('[WS] üì¢ Notificaci√≥n de evento (caseType:', data.caseType + ')');
                            showDynamicNotification(data);
                        }
                        else {
                            console.error('[WS] ‚ùå Notificaci√≥n sin notificationId ni caseType:', data);
                        }
                    }
                    
                    // Manejar c√≥digos recompensables
                    if (data && data.type === 'show_code') {
                        console.log('[WS] üéÅ C√≥digo recibido:', data.code);
                        showCode(data.code, data.duration, data.blink_start);
                    }
                    
                    // C√≥digo canjeado - remover de pantalla
                    if (data && data.type === 'code_redeemed') {
                        removeCode();
                    }
                } catch (e) {
                    console.warn('[WS] Error parseando mensaje:', e);
                }
            });

            ws.addEventListener('close', (event) => {
                console.log(`[WS] üî¥ Desconectado del servidor (C√≥digo: ${event.code})`);
                isConnecting = false;
                reconnectAttempts++;
                const delay = Math.min(3000 + (reconnectAttempts * 1000), 10000); // Max 10s
                console.log(`[WS] üîÑ Reintentando conexi√≥n en ${delay/1000}s...`);
                setTimeout(connectWebSocket, delay);
            });

            ws.addEventListener('error', (err) => {
                console.error('[WS] ‚ùå Error en WebSocket:', err);
                isConnecting = false;
                // El evento 'close' se disparar√° autom√°ticamente despu√©s del error
            });
        }

        // Inicializar al cargar la p√°gina
        window.addEventListener('load', () => {
            loadNotificationCatalog();
            connectWebSocket();
        });
    </script>
</body>
</html>